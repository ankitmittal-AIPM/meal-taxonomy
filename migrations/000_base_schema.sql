-- migrations/000_base_schema.sql
-- Base schema for Meal Taxonomy (Supabase / Postgres).
-- This file defines the core tables that the rest of the repo expects.
--
-- NOTE:
--   - This repo uses UUID primary keys for most entities.
--   - tag_types.id is an integer identity key (stable small ints).
--   - Additional search + brain tables (meal_variants, meal_synonyms, search RPC)
--     are added in later migrations.

-- Matches the uploaded schema dump:
--   - ontology_relations.predicate (TEXT)  ✅ NOT predicate_iri
--   - tag_ontology_links.relation (TEXT)
--   - ontology_nodes holds IRIs (ontology_nodes.iri)
--   - entity_ontology_links supports upsert(on_conflict="entity_type,entity_id,ontology_node_id,source")
-- Extensions ---------------------------------------------------------------

create extension if not exists pgcrypto;
create extension if not exists pg_trgm;
-- pgvector optional; enable if your project supports it
create extension if not exists vector;

-- -------------------------------------------------------------------
-- Helper: updated_at trigger
-- -------------------------------------------------------------------
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

-- -------------------------------------------------------------------
-- tag_types
-- -------------------------------------------------------------------
create table if not exists public.tag_types (
  id integer generated by default as identity primary key,
  name text not null unique,
  description text,
  created_at timestamptz not null default now()
);

-- -------------------------------------------------------------------
-- tags
-- (schema dump has: id uuid, tag_type_id integer, value text, label_en text, label_hi text)
-- -------------------------------------------------------------------
create table if not exists public.tags (
  id uuid primary key default gen_random_uuid(),
  tag_type_id integer not null references public.tag_types(id) on delete cascade,
  value text not null,
  label_en text,
  label_hi text
);

create unique index if not exists uq_tags_type_value
  on public.tags(tag_type_id, value);

create index if not exists idx_tags_value_trgm
  on public.tags using gin (value gin_trgm_ops);

-- -------------------------------------------------------------------
-- meals
-- (base table; later migrations may add extra columns)
-- -------------------------------------------------------------------
create table if not exists public.meals (
  id uuid primary key default gen_random_uuid(),

  title text not null,
  title_normalized text,

  description text,
  instructions text,

  source text,
  external_source text,
  external_id text,

  language_code text default 'en',

  cook_time_minutes integer,
  prep_time_minutes integer,
  total_time_minutes integer,
  servings numeric,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  meta jsonb,

  -- optional vector embedding (schema says USER-DEFINED; use vector if extension enabled)
  embedding vector(384),

  -- full text search vector (schema dump includes this)
  search_tsv tsvector
);

drop trigger if exists trg_meals_updated_at on public.meals;
create trigger trg_meals_updated_at
before update on public.meals
for each row execute function public.set_updated_at();

create index if not exists idx_meals_title_norm_trgm
  on public.meals using gin (title_normalized gin_trgm_ops);

create index if not exists idx_meals_search_tsv
  on public.meals using gin (search_tsv);

-- HNSW index for vector search (if pgvector supports it)
do $$
begin
  begin
    execute 'create index if not exists idx_meals_embedding_hnsw
             on public.meals using hnsw (embedding vector_cosine_ops)
             with (m = 16, ef_construction = 64)';
  exception when others then
    -- If HNSW not supported, skip silently (can be added later as ivfflat)
    null;
  end;
end $$;

-- -------------------------------------------------------------------
-- meal_variants
-- (schema dump has 22 columns)
-- -------------------------------------------------------------------
create table if not exists public.meal_variants (
  id uuid primary key default gen_random_uuid(),
  meal_id uuid not null references public.meals(id) on delete cascade,

  source_type text not null,
  source_id text not null,

  name text not null,
  description text,
  ingredients_text text,
  instructions_text text,

  cuisine text,
  course text,
  diet text,

  prep_time_mins numeric,
  cook_time_mins numeric,
  total_time_mins numeric,
  servings numeric,

  language_code text default 'en',

  tag_candidates jsonb,
  ingredients_norm text,
  instructions_norm text,
  extra jsonb,

  embedding vector(384),

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

drop trigger if exists trg_meal_variants_updated_at on public.meal_variants;
create trigger trg_meal_variants_updated_at
before update on public.meal_variants
for each row execute function public.set_updated_at();

create unique index if not exists uq_meal_variants_source
  on public.meal_variants(source_type, source_id);

do $$
begin
  begin
    execute 'create index if not exists idx_meal_variants_embedding_hnsw
             on public.meal_variants using hnsw (embedding vector_cosine_ops)
             with (m = 16, ef_construction = 64)';
  exception when others then
    null;
  end;
end $$;

-- -------------------------------------------------------------------
-- ingredients
-- (schema dump has: id, name_en, name_hi, ontology_term_iri, ontology_source, created_at, updated_at, meta)
-- -------------------------------------------------------------------
create table if not exists public.ingredients (
  id uuid primary key default gen_random_uuid(),

  name_en text not null,
  name_hi text,

  ontology_term_iri text,
  ontology_source text,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),

  meta jsonb
);

drop trigger if exists trg_ingredients_updated_at on public.ingredients;
create trigger trg_ingredients_updated_at
before update on public.ingredients
for each row execute function public.set_updated_at();

create unique index if not exists uq_ingredients_name_en
  on public.ingredients(lower(name_en));

create index if not exists idx_ingredients_name_en_trgm
  on public.ingredients using gin (name_en gin_trgm_ops);

-- -------------------------------------------------------------------
-- join tables: meal_ingredients, meal_tags
-- -------------------------------------------------------------------
create table if not exists public.meal_ingredients (
  id uuid primary key default gen_random_uuid(),
  meal_id uuid not null references public.meals(id) on delete cascade,
  ingredient_id uuid not null references public.ingredients(id) on delete cascade,
  quantity text,
  unit text,
  created_at timestamptz not null default now()
);

create unique index if not exists uq_meal_ingredients_meal_ing
  on public.meal_ingredients(meal_id, ingredient_id);

create index if not exists idx_meal_ingredients_meal
  on public.meal_ingredients(meal_id);

create index if not exists idx_meal_ingredients_ing
  on public.meal_ingredients(ingredient_id);

create table if not exists public.meal_tags (
  id uuid primary key default gen_random_uuid(),
  meal_id uuid not null references public.meals(id) on delete cascade,
  tag_id uuid not null references public.tags(id) on delete cascade,
  confidence numeric,
  source text,
  created_at timestamptz not null default now()
);

create unique index if not exists uq_meal_tags_meal_tag
  on public.meal_tags(meal_id, tag_id);

create index if not exists idx_meal_tags_meal
  on public.meal_tags(meal_id);

create index if not exists idx_meal_tags_tag
  on public.meal_tags(tag_id);

-- -------------------------------------------------------------------
-- meal_synonyms
-- (schema dump uses synonym/synonym_normalized — NOT name/name_normalized)
-- -------------------------------------------------------------------
create table if not exists public.meal_synonyms (
  id uuid primary key default gen_random_uuid(),
  meal_id uuid not null references public.meals(id) on delete cascade,
  synonym text not null,
  synonym_normalized text not null,
  language_code text default 'en',
  source text,
  created_at timestamptz not null default now()
);

create unique index if not exists uq_meal_synonyms_meal_norm_lang
  on public.meal_synonyms(meal_id, synonym_normalized, language_code);

create index if not exists idx_meal_synonyms_norm_trgm
  on public.meal_synonyms using gin (synonym_normalized gin_trgm_ops);

-- -------------------------------------------------------------------
-- ontology_nodes
-- -------------------------------------------------------------------
create table if not exists public.ontology_nodes (
  id uuid primary key default gen_random_uuid(),
  iri text not null,
  label text,
  kind text,
  source text,
  extra jsonb
);

create unique index if not exists uq_ontology_nodes_iri_source
  on public.ontology_nodes(iri, source);

create index if not exists idx_ontology_nodes_label_trgm
  on public.ontology_nodes using gin (label gin_trgm_ops);

-- -------------------------------------------------------------------
-- ontology_relations
-- IMPORTANT: predicate is TEXT (✅ matches your DB). No predicate_iri.
-- -------------------------------------------------------------------
create table if not exists public.ontology_relations (
  id uuid primary key default gen_random_uuid(),
  subject_id uuid not null references public.ontology_nodes(id) on delete cascade,
  predicate text not null,
  object_id uuid not null references public.ontology_nodes(id) on delete cascade,
  source text,
  extra jsonb
);

create unique index if not exists uq_ontology_relations_edge
  on public.ontology_relations(subject_id, predicate, object_id, source);

create index if not exists idx_ontology_relations_subject
  on public.ontology_relations(subject_id);

create index if not exists idx_ontology_relations_object
  on public.ontology_relations(object_id);

-- -------------------------------------------------------------------
-- entity_ontology_links
-- (schema dump includes extra jsonb; no created_at column in the dump)
-- -------------------------------------------------------------------
create table if not exists public.entity_ontology_links (
  id uuid primary key default gen_random_uuid(),
  entity_type text not null,
  entity_id uuid not null,
  ontology_node_id uuid not null references public.ontology_nodes(id) on delete cascade,
  confidence numeric,
  source text,
  extra jsonb
);

-- Must match Python on_conflict="entity_type,entity_id,ontology_node_id,source"
create unique index if not exists uq_entity_ontology_links_key
  on public.entity_ontology_links(entity_type, entity_id, ontology_node_id, source);

create index if not exists idx_entity_ontology_links_entity
  on public.entity_ontology_links(entity_type, entity_id);

create index if not exists idx_entity_ontology_links_node
  on public.entity_ontology_links(ontology_node_id);

-- -------------------------------------------------------------------
-- tag_ontology_links
-- relation is TEXT (schema dump)
-- -------------------------------------------------------------------
create table if not exists public.tag_ontology_links (
  id uuid primary key default gen_random_uuid(),
  tag_id uuid not null references public.tags(id) on delete cascade,
  ontology_node_id uuid not null references public.ontology_nodes(id) on delete cascade,
  relation text not null,
  extra jsonb
);

create unique index if not exists uq_tag_ontology_links_key
  on public.tag_ontology_links(tag_id, ontology_node_id, relation);

create index if not exists idx_tag_ontology_links_tag
  on public.tag_ontology_links(tag_id);

create index if not exists idx_tag_ontology_links_node
  on public.tag_ontology_links(ontology_node_id);

-- -------------------------------------------------------------------
-- Optional: search TSV maintenance trigger for meals
-- This stays light in base schema; fuller doc aggregation can be in later migrations.
-- -------------------------------------------------------------------
create or replace function public.meals_set_search_tsv()
returns trigger
language plpgsql
as $$
begin
  -- Default to title + title_normalized if present.
  new.search_tsv :=
    to_tsvector(
      'simple',
      coalesce(new.title,'') || ' ' || coalesce(new.title_normalized,'')
    );
  return new;
end;
$$;

drop trigger if exists trg_meals_search_tsv on public.meals;
create trigger trg_meals_search_tsv
before insert or update of title, title_normalized on public.meals
for each row execute function public.meals_set_search_tsv();
